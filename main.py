from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from langchain_agent import LangChainAgent
import logging
import json
from openai import OpenAI
from db_manager import DatabaseManager

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI()

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://storied-tartufo-11d3ec.netlify.app"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize OpenAI client
client = OpenAI()

class Query(BaseModel):
    text: str
    chart_type: str | None = None
    connection_id: int | None = None

class DBConnectionCreate(BaseModel):
    name: str
    host: str
    port: int
    database: str
    username: str
    password: str

class DBConnectionTest(BaseModel):
    host: str
    port: int
    database: str
    username: str
    password: str

# Initialize LangChain agent
agent = LangChainAgent()

def suggest_chart_type(api_text: str) -> str:
    """Suggest the best chart type based on the data"""
    prompt = f"""
    Based on the following data, suggest the best chart type (bar, line, area, pie, donut, card):
    {api_text}
    
    Return only the chart type name in lowercase.
    """
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2
        )
        return response.choices[0].message.content.strip().lower()
    except Exception as e:
        logger.error(f"Error suggesting chart type: {str(e)}")
        return "card"  # Fallback to card display

def parse_text_to_json(final_answer: str, chart_type: str):
    """Parse text response into ECharts-compatible JSON format"""
    prompt = f"""
    Parse the following text into a JSON format suitable for ECharts {chart_type} chart.
    Extract numerical values and their corresponding labels.
    Use this schema:
    {{
      "xAxis": {{ "type": "category", "data": [] }},
      "yAxis": {{ "type": "value" }},
      "series": [{{ "data": [], "type": "{chart_type}" }}]
    }}
    
    For pie/donut charts, use:
    {{
      "series": [
        {{
          "type": "pie",
          "data": [{{"value": 0, "name": "label"}}]
        }}
      ]
    }}
    
    For card display, use:
    {{
      "type": "card",
      "content": "text summary"
    }}
    
    Text: {final_answer}
    """
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1
        )
        json_output = response.choices[0].message.content
        
        # Validate JSON
        parsed = json.loads(json_output)
        return parsed
    except json.JSONDecodeError:
        logger.error("Invalid JSON generated by LLM")
        return {"error": "Failed to generate valid chart data"}
    except Exception as e:
        logger.error(f"Error parsing text to JSON: {str(e)}")
        return {"error": str(e)}

@app.post("/query")
async def handle_query(query: Query):
    try:
        logger.info(f"Processing query: {query.text}")
        
        try:
            result = agent.process_query(query.text)
        except Exception as agent_error:
            logger.error(f"Error in agent processing: {str(agent_error)}")
            return {
                "status": "error",
                "message": "Failed to process query",
                "error": str(agent_error)
            }
            
        if not result or not isinstance(result, dict):
            raise HTTPException(status_code=500, detail="Invalid response from agent")
            
        logger.info(f"Query processed. Status: {result.get('status')}")
        
        final_answer = result.get("llm_analysis", {}).get("final_answer")
        suggested_chart = suggest_chart_type(final_answer)
        
        # Use suggested chart if none was specified
        chart_type = query.chart_type or suggested_chart
        chart_data = parse_text_to_json(final_answer, chart_type)
        
        response = {
            "status": "success",
            "data": {
                "answer": final_answer,
                "sql_query": result.get("sql_data", {}).get("query"),
                "sql_results": result.get("sql_data", {}).get("results"),
                "chart_data": chart_data,
                "suggested_chart": suggested_chart
            }
        }
        
        return response
        
    except Exception as e:
        logger.error(f"Exception in handle_query: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/test")
async def test_endpoint():
    """Test endpoint to verify API functionality"""
    test_queries = [
        "Show me total sales by product for 2023",
        "Display the monthly sales trend for Product A in 2023",
        "What is the market share distribution among our competitors?"
    ]
    
    results = []
    for query in test_queries:
        try:
            result = agent.process_query(query)
            final_answer = result.get("llm_analysis", {}).get("final_answer")
            suggested_chart = suggest_chart_type(final_answer)
            chart_data = parse_text_to_json(final_answer, suggested_chart)
            
            results.append({
                "query": query,
                "status": result.get("status"),
                "answer": final_answer,
                "has_sql": bool(result.get("sql_data", {}).get("query")),
                "has_results": bool(result.get("sql_data", {}).get("results")),
                "suggested_chart": suggested_chart,
                "chart_data": chart_data,
                "error": None
            })
        except Exception as e:
            results.append({
                "query": query,
                "status": "error",
                "answer": None,
                "has_sql": False,
                "has_results": False,
                "suggested_chart": None,
                "chart_data": None,
                "error": str(e)
            })
    
    return {
        "status": "success",
        "test_results": results
    }

@app.post("/connections/test")
async def test_connection(conn: DBConnectionTest):
    """Test a database connection"""
    try:
        DatabaseManager.test_connection(
            host=conn.host,
            port=conn.port,
            database=conn.database,
            username=conn.username,
            password=conn.password
        )
        return {"status": "success", "message": "Connection test successful"}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/connections")
async def add_connection(conn: DBConnectionCreate):
    """Add a new database connection"""
    try:
        result = DatabaseManager.add_connection(
            name=conn.name,
            host=conn.host,
            port=conn.port,
            database=conn.database,
            username=conn.username,
            password=conn.password
        )
        return {"status": "success", "data": result}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/connections")
async def list_connections():
    """List all database connections"""
    try:
        connections = DatabaseManager.get_connections()
        return {"status": "success", "data": connections}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/connections/{connection_id}")
async def get_connection(connection_id: int):
    """Get a specific database connection"""
    try:
        connection = DatabaseManager.get_connection(connection_id)
        return {"status": "success", "data": connection}
    except Exception as e:
        raise HTTPException(status_code=404, detail=str(e))

@app.delete("/connections/{connection_id}")
async def delete_connection(connection_id: int):
    """Delete a database connection"""
    try:
        result = DatabaseManager.delete_connection(connection_id)
        return {"status": "success", "data": result}
    except Exception as e:
        raise HTTPException(status_code=404, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
